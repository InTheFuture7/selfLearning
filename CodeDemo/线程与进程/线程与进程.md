## 线程

线程池是一个维护一组**可重用**线程的**管理**器，可以统一管理线程的创建、调度和销毁，你只需提交任务，它来决定谁来执行。

> 线程池可以理解为一个管理餐馆中所有厨师的管理器

## 代码样例1

理解线程池的创建和关闭、任务分配

```python
from concurrent.futures import ThreadPoolExecutor

def io_task():
    """定义一个 io 任务"""
    pass

# 线程池的创建与关闭
with ThreadPoolExecutor(max_workers=3) as executor:
    # 将任务分配给一个线程，并返回 future 对象
    future = executor.submit(io_task)
    # 该线程会等待任务完成
    result = future.result()
```

- 创建线程池
使用 with 语句创建线程池，当不再接受新任务，并等待所有已提交任务完成后，自动关闭线程池。

- future 对象
使用 ThreadPoolExecutor 或 ProcessPoolExecutor 提交任务时，返回一个 Future 对象，表示一个任务。可以理解为：取前台点餐会受到一个取单号（Future），可以根据这个取单号去询问订单状态等信息。

- submit()
让线程执行函数，非阻塞

- result()
等待任务完成，阻塞

## 代码样例2
面对任务多于线程数、任务耗时不同的情况，如何实现更优的调度

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import random

def io_task(name):
    pass

with ThreadPoolExecutor(max_workers=3) as executor:
    # 创建 5 个任务
    futures = [executor.submit(io_task, f"任务{i}") for i in range(5)]
    # 将 5 个任务分配给 3 个线程，做的快的线程做的多
    for future in as_completed(futures):
        result = future.result()
```

as_completed() 应用场景：
1. 任务很多，线程有限：谁先完成就先处理
2. 任务耗时不同：不用等慢任务，可以优先处理快任务


## 代码样例2

map() 并发地开始所有任务，按照传入参数顺序完成任务，阻塞式等待每一个结果，最终输出结果和输入顺序一致。


---


submit和map是分配任务的方式吗？

as_completed和result()是执行任务地方式吗？as_completed会让先完成任务的线程继续完成后续任务，result会怎么办呢？

submit()一次性分配所有任务给线程，如果线程数小于任务数，会怎么办呢？






提示词的优化

> 一开始没有总体的路线图
> 应该将总的任务划分成若干小节，每一节完成后要求用户反馈理解，并评估用户的学习效果。进而判断是否要进入下一节的学习